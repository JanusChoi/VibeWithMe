# 经验教训模板

记录项目开发过程中遇到的问题、解决方案和经验。这是项目最有价值的文档。

---

## 📋 文档说明

| 项 | 值 |
|----|-----|
| **所属版本** | vX.X.X |
| **开发周期** | YYYY-MM-DD 至 YYYY-MM-DD |
| **文档更新** | YYYY-MM-DD |

---

## 🎯 为什么记录经验教训？

1. **知识沉淀** - 将问题解决方案记录下来
2. **快速决策** - 下次遇到类似问题，直接查看方案
3. **风险预防** - 了解常见坑，主动规避
4. **个人成长** - 记录学到的经验，持续进步
5. **持续改进** - 基于数据改进开发流程

---

## 🚨 问题记录格式

### 问题分类

按照问题的来源和性质分类：

```
需求管理类
├── 需求变更频繁
├── 需求不清晰
└── 需求范围蔓延

技术选型类
├── 框架选择不当
├── 依赖库版本冲突
└── 性能指标不达标

开发流程类
├── 分支管理混乱
├── 流程执行混乱
└── 测试覆盖不足

代码质量类
├── 代码重复
├── 耦合度高
└── 文档不清

沟通协作类（人类与AI）
├── 需求理解偏差
├── 优先级不明确
└── 反馈不及时

基础设施类
├── 环境配置问题
├── 构建失败
└── 部署异常
```

### 标准模板

```markdown
# [问题编号] 问题标题

**严重程度**: P0 / P1 / P2 / P3  
**分类**: [需求管理 / 技术选型 / 开发流程 / 代码质量 / 沟通协作 / 基础设施]  
**发现日期**: YYYY-MM-DD  
**发现阶段**: [开发 / 测试 / 生产]

## 问题描述

清晰描述现象和影响范围...

## 问题根因

分析为什么会出现这个问题...

## 尝试过的方案

描述尝试过的多种解决方案...

## 最终解决方案

记录最终的有效解决方案...

## 验证结果

说明如何验证问题已解决...

## 防止措施

为了避免下次重复，应该做什么...

## 关键学习

从这个问题中学到的最重要的东西...
```

---

## 📊 问题案例

### 案例1: 数据库迁移导致数据丢失 (P0)

**严重程度**: P0 紧急  
**分类**: 技术选型 + 开发流程  
**发现日期**: 2025-10-15  
**发现阶段**: 生产

#### 问题描述

升级到新版本时，用户的所有历史数据（2年的交易记录）全部丢失。

影响:
- 用户无法查看历史数据
- 统计分析无法进行
- 严重影响用户信任

#### 问题根因

初始化脚本在创建新数据库时，没有检查是否存在旧数据库。直接创建新schema，导致旧数据被覆盖。

根本原因：
1. 升级流程设计不周
2. 没有数据迁移测试
3. 没有备份验证

#### 尝试的方案

方案A: 从备份恢复 ❌
- 问题: 备份也是新schema（备份前就已经覆盖了）
- 耗时: 无法进行

方案B: 从旧库恢复 ✅
- 发现了客户本地备份的旧数据库文件
- 编写脚本恢复历史数据
- 成功恢复95%的数据
- 耗时: 8小时

#### 最终解决方案

1. **恢复历史数据**
   ```python
   def migrate_from_old_db(old_db_path):
       # 检查旧数据库是否存在
       if os.path.exists(old_db_path):
           # 读取旧数据
           old_data = read_from_old_schema(old_db_path)
           # 转换到新schema
           new_data = transform_to_new_schema(old_data)
           # 写入新数据库
           write_to_new_db(new_data)
           return True
       return False
   ```

2. **升级脚本改进**
   - 升级前: 备份旧数据库
   - 升级时: 先读旧数据，再创建新schema
   - 升级后: 验证数据完整性

3. **测试增强**
   - 编写数据迁移测试
   - 包含各种数据量的测试
   - 边界情况测试

#### 防止措施

1. **流程改进**
   - 所有数据库升级必须有迁移方案
   - 升级脚本必须支持回滚
   - 升级前必须备份

2. **代码审查加强**
   - 所有数据库操作代码必须特别审查
   - 迁移脚本需要二次确认
   - 生产环境变更需要演习

3. **测试覆盖**
   - 数据库升级需要特定测试
   - 包括各种旧版本的升级路径
   - 数据完整性验证

4. **文档完善**
   - 编写升级手册
   - 记录升级步骤和验证方法
   - 包括回滚方案

#### 关键学习

**向后兼容 > 新功能**

- 升级保留用户数据比任何新功能都重要
- 数据安全是产品的基础
- 任何数据操作都应该谨慎对待
- 备份和验证不能省

---

### 案例2: 代码性能问题导致卡顿

**严重程度**: P1 高  
**分类**: 开发流程 + 代码质量  
**发现日期**: 2025-10-20  
**发现阶段**: 生产

#### 问题描述

用户反馈: 某个查询页面在加载100条数据时需要5秒以上才能响应，严重影响用户体验。

性能指标:
- 期望: < 500ms
- 实际: 5000ms
- 性能缺口: 10倍

#### 问题根因

性能分析发现: N+1查询问题

代码逻辑:
```python
# 查询100条用户
users = User.query.limit(100).all()

# 对每条用户查询其订单（N+1）
for user in users:
    orders = Order.query.filter(Order.user_id == user.id).all()
    user.orders = orders
```

这导致:
- 1次查询获取100个用户
- 100次查询获取每个用户的订单
- 共101次数据库查询

#### 最终解决方案

使用关联查询（Join）替代循环查询：

```python
# 改进后: 只需2次查询
users = User.query.limit(100).all()
user_ids = [u.id for u in users]
orders = Order.query.filter(Order.user_id.in_(user_ids)).all()

# 在内存中关联
order_map = {}
for order in orders:
    if order.user_id not in order_map:
        order_map[order.user_id] = []
    order_map[order.user_id].append(order)

for user in users:
    user.orders = order_map.get(user.id, [])
```

或使用ORM的关联加载:

```python
# SQLAlchemy: 使用joinedload
users = User.query.options(
    joinedload(User.orders)
).limit(100).all()
```

性能对比:
- 改进前: 5000ms
- 改进后: 150ms
- 性能提升: 33倍

#### 防止措施

1. **代码审查加强**
   - 检查所有数据库查询
   - 特别关注循环中的查询
   - 验证查询数量

2. **性能测试**
   - 每个功能都应该有性能基准
   - 测试不同数据量下的性能
   - 设置性能告警

3. **工具辅助**
   - 使用慢查询日志检测
   - 使用APM工具监控
   - 定期进行性能分析

#### 关键学习

**性能从设计开始，不是优化时才考虑**

- 写代码时就要考虑性能
- 数据库查询特别需要注意
- 循环中的数据库操作是常见陷阱
- 性能问题往往很容易被忽视

---

### 案例3: 需求变更导致工期延期

**严重程度**: P2 中  
**分类**: 需求管理 + 沟通协作  
**发现日期**: 2025-10-25  
**发现阶段**: 开发

#### 问题描述

计划完成时间: 1周  
实际完成时间: 2周  
延期原因: 需求在开发过程中频繁变更

变更时间线:
- Day 1: 开始需求分析，得到初版需求文档
- Day 2: 开始设计，客户反馈需要增加新功能
- Day 3: 开始开发，客户又要修改之前定义的字段
- Day 4: 已经开发的模块需要重构，因为需求变了
- Day 5: 完成开发，但客户说漏了重要功能

#### 问题根因

根本原因: 需求定义过程不够严格

问题:
1. 初期需求讨论不充分
2. 没有需求冻结点
3. 客户在开发中提需求
4. 需求变更流程不规范

#### 最终解决方案

建立严格的需求管理流程:

1. **需求定义阶段(Day 1-2)**
   - 详细采集所有需求
   - 编写完整的USER_STORIES.md
   - 包括所有边界情况
   - 明确验收标准

2. **需求冻结点(Day 2 EOD)**
   - 需求定版并签字确认
   - 明确告知客户: 之后变更需要评估影响
   - 记录冻结时间

3. **变更管理流程**
   - 任何变更都需要提交变更单
   - 评估对工期的影响
   - 客户决策: 是否延期或删除其他功能
   - 正式文档更新

4. **进度同步**
   - 每天同步进度
   - 及时发现需求理解偏差
   - 立即澄清和调整

#### 防止措施

1. **需求阶段强化**
   - 分配足够时间做需求分析
   - 使用结构化的需求文档
   - 包含原型/设计图
   - 多方评审确认

2. **需求冻结制**
   - 明确冻结时间
   - 进行最终评审
   - 双方签字确认
   - 记录基线版本

3. **变更管理**
   - 建立变更申请流程
   - 评估变更影响
   - 透明沟通工期影响
   - 文档更新

4. **每日同步**
   - 发现需求理解偏差时及时调整
   - 不要等到后期才发现问题
   - 保持清晰的沟通

#### 关键学习

**需求清晰 > 代码速度**

- 花时间做好需求分析最划算
- 不清晰的需求最终会浪费更多时间
- 开发过程中的需求变更代价很大
- 提前沟通和澄清能节省大量时间

---

## 📈 问题统计分析

### 按严重程度分布

```
P0 (紧急)  : 1个  █████░░░░░░░░░░░░░░  5%
P1 (高)    : 3个  ███████████░░░░░░░░░  15%
P2 (中)    : 8个  ██████████████████░░░ 40%
P3 (低)    : 8个  ██████████████████░░░ 40%

总计: 20个问题
```

### 按分类统计

```
需求管理      : 3个  (15%)
技术选型      : 4个  (20%)
开发流程      : 5个  (25%)
代码质量      : 4个  (20%)
沟通协作      : 2个  (10%)
基础设施      : 2个  (10%)
```

### 重复问题

```
重复类别      : N+1查询 (性能问题的30%)
频繁问题      : 需求理解偏差 (需求类问题的50%)
最易忽视      : 文档更新 (导致后续问题)
```

---

## 🎓 个人学习成果

### 学到的最重要的事

1. **三条金律**
   - 向后兼容 > 新功能
   - 性能从设计开始
   - 需求清晰 > 代码速度

2. **开发的最佳实践**
   - 数据库操作需要特别谨慎
   - 代码审查真的很重要
   - 性能问题容易被忽视
   - 需求文档是基础

3. **个人成长**
   - 提高了代码质量意识
   - 学会了系统的问题分析
   - 认识到沟通的重要性

### 推荐下个版本应该

1. **流程改进**
   - [ ] 强化代码审查标准
   - [ ] 增加性能测试
   - [ ] 建立需求冻结制

2. **技能提升**
   - [ ] 学习性能优化技术
   - [ ] 提升数据库设计能力
   - [ ] 改进需求分析能力

3. **工具引入**
   - [ ] 引入性能监控工具
   - [ ] 使用代码质量扫描
   - [ ] 建立自动化测试

---

## 📚 附录：常见问题库

### Q: 如何从失败中恢复？

A:
```
1. 冷静分析: 发生了什么，为什么会这样
2. 快速响应: 采取措施控制影响
3. 根本改进: 为什么没有提前发现
4. 文档记录: 写成案例，避免重复
```

### Q: 什么时候应该推迟发布？

A:
```
应该推迟的情况:
- 发现P0级bug且难以快速修复
- 性能严重不达标 (>2倍差距)
- 数据安全问题
- 关键功能缺失或不可用

不应该推迟的情况:
- P1/P2级问题可以版本发布后修复
- 次要功能缺失
- 非关键性能问题
```

### Q: 如何避免同类问题？

A:
```
1. 识别问题的根本原因
2. 确定预防措施
3. 更新流程或检查清单
4. 对团队（或自己）进行培训
5. 定期审查防止措施是否有效
```

---

## 🔄 持续改进

### 每个版本应该

- [ ] 记录所有P0级问题
- [ ] 记录所有P1级问题
- [ ] 分析问题的共同原因
- [ ] 制定改进措施
- [ ] 追踪改进的效果

### 每个季度应该

- [ ] 汇总问题统计
- [ ] 识别最频繁的问题类型
- [ ] 制定季度改进计划
- [ ] 评估上季度改进效果

---

**版本**: v2.0 (人类与AI协同)  
**最后更新**: 2025年10月
